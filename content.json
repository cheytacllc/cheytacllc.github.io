{"pages":[{"title":"","text":"title: Categoriesdate: 2017-03-29 01:15:36type: “Categories”","link":"categories/index.html"},{"title":"about","text":"","link":"about/index.html"}],"posts":[{"title":"C Stili Dizilerden std::array'e...","text":"Programlama dillerinde diziler uygulanırken syntax olarak genelde C stili dizilerden ilham aldılar. Özellik olarak C stili dizilerin üzerine ihtiyaca göre üye fonksiyonlar da eklendi. C++11 ile gelen std::array ile C stili dizilerden çok daha fazla kullanışlılığa ve okunabilirliğe sahip kod yazılırken performans anlamında ise neredeyse aynı seviyede sayılır. std::array C stili diziler gibi statik boyutludur ve bellekte derleme zamanında yer ayrılır. std::array’ e genel bakışstd::array arka planda C stili dizinin ve ilgili üye fonksiyonlarının bulunduğu array sınıf şablonu yapısındadır. 123456789template&lt;typename T, size_t N&gt;class array{public: T _data[N]; T&amp; operator[](size_t); const T&amp; operator[](size_t) const; // other member functions and typedefs}; std::array kullanmak için #include &lt;array&gt; ile array kütüphanesi projeye eklenir. std::array uzunluğu derleme zamanında hesaplandığından ve o bilgi oluşturulan nesne içerisindeki bir değişkende saklandığından sonradan o std::array nesnesinin uzunluğunu öğrenmek kolay ve hızlıdır. std::array oluşturmakstd::array iki bileşenden oluşur: İlki array içinde saklanacak elemanların tipi ve ikincisi array nesnesinin ne kadar eleman tutacağı (yani uzunluğu). 12345//a1 dizisi 10 int tipinde eleman tutarstd::array&lt;int, 10&gt; a1;//Tanımlama sırasında değerler atanabilirstd::array&lt;int, 5&gt; a2 = {-1, 1, 3, 2, 0}; Ayrıca mevcut diziler yeni dizilere atama yoluyla kopyalanabilir. 12345//atama yoluyla yeni kopya dizi oluşturmaauto a3 = a2;//constructor ile de kopya dizi oluşturulabilirauto a4(a2); Aynı uzunluktaki başka bir dolu diziye = operatörü ile atama yapılabilir ama uzunluklar aynı olmadığında hata alınacaktır. 123456//a3 dizisi değerlerini a2 dizisine atamaa2 = a3;// &apos;=&apos; operatörü iki dizi aynı boyutta ise kullanılabilir.//Hata://a1 = a2; //&lt;[...],10&gt; vs &lt;[...],5&gt;! geçersiz std::array içindeki verilere erişmekstd::array içindeki verilere dizilerden alıştığımız şekilde [] operatörü ile de erişebiliriz ama sınır kontrolü yapmadığından dizi boyutundan farklı değerlerde hata alınacaktır. 12//beklenilen şekilde değer atamaları gerçekleşira3[0] = -2; Sınır kontrolü için at() üye fonksiyonu kullanılabilir. 1234std::cout &lt;&lt; &quot;a2.at(4): &quot; &lt;&lt; a2.at(4) &lt;&lt; std::endl;// Sınır kontrolü istisna yaratabilir. Deneyin://auto b = a2.at(10); Ayrıca front() ve back() üye fonksiyonlarıyla array nesnesindeki ilk ve son değerlere erişebiliriz. data() üye fonksiyonustd::array dolaylı yoldan raw pointera dönüşmez. Pointer temelli kullanmak isteniyorsa data() üye fonksiyonu kullanmak gerekir.Örneğin buffer arayüzü için C stili API yazalım: 1234void carr_func(int * arr, size_t size){ std::cout &lt;&lt; &quot;carr_func - arr: &quot; &lt;&lt; arr &lt;&lt; std::endl;} carr_func fonksiyonunda ilk parametreye std::array gönderirsek derleyici hatası oluşur. 123456../../array.cpp:44:2: error: no matching function for call to &apos;carr_func&apos; carr_func(a2); ^~~~~~~~~../../array.cpp:4:6: note: candidate function not viable: no known conversion from &apos;std::array&lt;int, 5&gt;&apos; to &apos;int *&apos; for 1st argumentvoid carr_func(int * arr) Bunun yerine data() üye fonksiyonunu kullanınca sorun çözülür. 12345//Error://carr_func(a2, a2.size());//OK:carr_func(a2.data(), a2.size()); size() ve empty() üye fonksiyonlarısize() üye fonksiyonuyla dizinin uzunluğu öğrenilebilir. empty() üye fonksiyonu ise dizinin içeriği boş ise true, dolu ise false döndürür. 1234a2.size(); //5std::array&lt;int, 0&gt; a_empty;a_empty.empty(); //true Container(kap) işlemleristd::array container sınıfı olduğundan temel container arayüzlerini sunmaktadır. std::array statik uzunlukta olduğundan dinamik olarak uzunluk değiştirme gibi işlemler mevcut değildir. Ancak std::sort gibi sıralama fonksiyonları kullanılabilir. 1std::sort(a1.begin(), a1.end()); İleri okuma ve kaynaklar cppreference: std::array Makaleler/Açıklamalar An Introduction to std::array C++11 Features – std::array std::array: The Secure, Convenient Option for Fixed-size Sequences","link":"2019/11/17/C-Stili-Dizilerden-std-array-e/"},{"title":"Github Pages Hexo ile PWA ve Daha Fazlası","text":"Daha önce Github Pages üzerine Hexo kurulumundan bahsetmiştik. Şimdi siteye PWA, Push notification, AMP ve TeX render gibi özellikler ekleyeceğiz. 0. Hexo Sürümü KontrolüOlabilecek uyumsuzlukları ve sorunları engellemek için hexo sürümünün 4.1.1 sürümünden yüksek olmaması önerilir. Bu yüzden Hexo sürümü daha yeniyse kaldırılıp 4.1.1 versiyonunun yüklenmesi gerekir.12npm uninstall hexonpm install hexo@4.1.1 1. TeX Render EtkinleştirmeMatematiksel ifadeleri yazmanın en kolay yolu TeX syntax kullanmaktır. Ama bunu render yapmadıktan sonra pek bir anlam ifade etmiyor. Bunun için Hexo Plugins bölümünde bir eklenti mevcut: hexo-mathEklentiyi yüklemek için sitenin olduğu klasörde terminal penceresi açıp1npm install hexo-math --savekomutunu yazarak hexo-math eklentisinin indirilip yüklenmesini sağlayın. Daha sonra _config.yml dosyasına şu satırları ekleyin:12math: engine: &apos;mathjax&apos; # or &apos;katex&apos;Bu aşamadan sonra hexo-math kurulumu tamamlandı. Şimdi yazmaya başlayabiliriz.Satır içi matematiksel ifade yazmak için $\\Delta=b^2-4ac$ gibi ifadeyi $ işaretlerinin arasına yazın. Böyle görünecek: $\\Delta=b^2-4ac$Ayrı satırda yazmak için ise yeni satırda$$x_1,x_2=\\frac{-b\\pm\\sqrt{\\Delta}}{2a}$$ şeklinde ikişer $ işaretleri arasında yazın. Böyle görünecektir:$$x_1,x_2=\\frac{-b\\pm\\sqrt{\\Delta}}{2a}$$ 2. PWA EtkinleştirmeSiteyi ana ekrana uygulama kısayolu gibi ekleme ve önbellek üzerinde offline görüntülemek için en etkin yol PWA yapmaktır. Bunun için Hexo Plugins kısmında eklenti mevcut. Eklentiyi yüklemek için sitenin olduğu klasörde terminal penceresi açıp1npm install --save hexo-pwakomutunu yazarak hexo-pwa eklentisinin indirilip yüklenmesini sağlayın. Daha sonra _config.yml dosyasına şu satırları ekleyin:1234567891011121314151617181920212223242526272829303132333435363738pwa: manifest: path: /manifest.json body: name: your-app-name short_name: your-app-name theme_color: white background_color: white display: standalone orientation: portrait scope: / start_url: / icons: - src: /images/applogo.png sizes: 192x192 type: image/png serviceWorker: path: /sw.js preload: urls: - / posts: 20 opts: networkTimeoutSeconds: 5 routes: - pattern: !!js/regexp /hm.baidu.com/ strategy: networkOnly - pattern: !!js/regexp /www.google-analytics.com/ strategy: networkOnly - pattern: !!js/regexp /pagead2.googlesyndication.com/ strategy: networkOnly - pattern: !!js/regexp /cdn.jsdelivr.net/ strategy: cacheFirst - pattern: !!js/regexp /.*\\.(js|css|jpg|jpeg|png|gif)$/ strategy: cacheFirst - pattern: !!js/regexp /\\// strategy: networkFirst priority: 5Yukarıdaki kod parçasında your-app-name kısmını uygulama listesinde görünmesini istediğiniz ad olarak değiştirebilirsiniz ve icons: src: /images/applogo.png kısmını da kullandığınız tema klasöründeki logoya göre ayarlayabilirsiniz. Bu aşamadan sonra hexo-pwa kurulumu tamamlanmış ve siteye girdiğinizde ana ekrana ekleme bildirimi çıkacaktır. 3. AMP EtkinleştirmeAMP (Accelerated Mobile Pages) ile mobilde sayfalar daha minimal ve hızlı yüklenir. Bunun için Hexo Plugins kısmında eklenti mevcut. Eklentiyi yüklemek için sitenin olduğu klasörde terminal penceresi açıp1npm install hexo-generator-amp --savekomutunu yazarak hexo-amp eklentisinin indirilip yüklenmesini sağlayın. Daha sonra _config.yml dosyasına şu satırları ekleyin:123456789101112131415 # hexo-generator-amp# The following settings is the quick start options.generator_amp: templateDir: amp-template assetDistDir: amp-dist logo: path: sample/sample-logo.png width: 600 height: 60 substituteTitleImage: path: sample/sample-substituteTitleImage.png width: 1024 height: 800 warningLog: false # To display warning, please set true.Ardından kullandığınız temanın içerisindeki head.ejs (Örnek dosya yolu: themes/(your-theme)/layout/_partial/head.ejs) içerisine123&lt;% if (is_post() &amp;&amp; config.generator_amp){ %&gt; &lt;link rel=&quot;amphtml&quot; href=&quot;&lt;%= config.url %&gt;&lt;%= config.root %&gt;&lt;%= page.path %&gt;/amp/index.html&quot;&gt;&lt;% } %&gt;satırlarını ekleyip kaydedin. Artık AMP kurulumunu tamamlandı ve hexo generate esnasında AMP sayfaları da oluşturacak. 4. Push Notifications EtkinleştirmeSitede yeni yazı yayınlandığında kullanıcılara Push Notification gönderebiliriz. Bunun için hexo-web-push-notification eklentisi mevcuttur. Eklentiyi yüklemek için sitenin olduğu klasörde terminal penceresi açıp1npm i hexo-web-push-notification --savekomutunu yazarak hexo-web-push-notification eklentisinin indirilip yüklenmesini sağlayın. Ardından _config.yml dosyasına alttaki satırları ekleyerek gerekli düzenlemeleri yapın:1234webPushNotification: webpushrKey: &quot;your-rest-api-key&quot; webpushrAuthToken: &quot;your-auth-token&quot; trackingCode: &quot;AEGlpbdgvBCWXqXI6PtsUzobY7TLV9gwJU8bzMktrwfrSERg_xnLVbjpCw8x2GmFmi1ZcLTz0ni6OnX5MAwoM88&quot; Öncelikli olarak push bildirim gönderebilmek için webpushr adlı servise kaydolup siteyi ekliyoruz. Ardından buradan rest-api key ve auth token edinip yukarıdaki ilgili alanlara ekliyoruz ve buradaki kod bloğunda yukarıdaki gibi dizilmiş uzun karakter serisini kopyalayıp yukarıdaki kod parçasında trackingCode alanına yapıştırıyoruz. Artık siteye girildiğinde bildirim gönderimi soracak ve izin verildiğinde yeni yazılarda bildirim gönderecek.","link":"2020/05/22/Github-Pages-Hexo-ile-PWA-ve-Daha-Fazlasi/"},{"title":"Github Pages Üzerine Hexo Kurulumu","text":"Github Pages ile your-github-username.github.io üzerinde kendi statik sayfamızı yayınlayabiliyoruz. Çeşitli geliştiriciler bu sistem üzerinde blog inşası için çeşitli static site generator araçları yayınlıyor. İçlerinde gördüğüm kadarıyla Hexo çeşitli tema ve eklenti desteğiyle öne çıkıyor. 1. Gereksinimler Node.js ve npm Hexo, node.js üzerinde çalıştığından npm kurulumu gerekmektedir. Windowsx86 ya da x64 kurulum dosyaları LinuxAltta dnf yerine kullandığınız dağıtımın paket yöneticisini yazın (apt-get gibi) 1sudo dnf install nodejs npm MacOS 12brew updatebrew install node GitYazı yazdıktan sonra github-pages’e deploy etmek için git kullanılacaktır. Windowsx86 ya da x64 kurulum dosyaları LinuxAltta dnf yerine kullandığınız dağıtımın paket yöneticisini yazın (apt-get gibi) 1sudo dnf install git MacOS 12brew updatebrew install git 2. Hexo kurulumuYukarıdaki gereksinimleri sağladıktan sonra terminal penceresi açıp12npm install hexo-cli -gnpm install hexo-deployer-git --saveyazarak npm üzerinden Hexo kurulumunu gerçekleştirin. Linux sistemlerde komutun başına sudo koymak gerekebilir.Kurulum gerçekleştikten sonra blog/site dosyalarını saklayacağınız bir klasör oluşturup o klasör içerisinde terminal penceresi açarak12hexo init your-github-username.github.ionpm installyazarak bulunduğunuz klasör içinde your-github-username.github.io klasörünün oluştuğunu ve içerisine Hexo dosyalarının kopyalandığını göreceksiniz.your-github-username.github.io klasöründeki _config.yml dosyasını açarak title, url, author gibi değişkenleri kendinize göre ayarladıktan sonra deploy: kısmını alttaki gibi ayarlayın (your-github-username kısmını kendinizin username ile değiştirmeniz gerektiğini söylememe gerek yok)_config.yml1234deploy: type: git repo: https://github.com/your-github-username/your-github-username.github.io branch: master 2.1. Github Git bağlantısı Yazıyı github-pages’e deploy edebilmek için Git clienti github için ayarlayıp ssh key alacağız. Öncelikle terminal açıp (windows’da git bash) 12git config --global user.name &quot;your-github-username&quot;git config --global user.email &quot;your_email@example.com&quot; komutlarını uyguladıktan sonra ssh key oluşturmak için 1ssh-keygen -t rsa -C &quot;your_email@example.com&quot; komutunu yazınca &gt; Enter a file in which to save the key (/home/you/.ssh/id_rsa): [Press enter] sorusuyla public ssh key dosyasını kaydetme yeri sorulacaktır, Enter basarak default konumu kullanacağız. Sonra passphrase oluşturmamızı isteyecektir passphrase yazıp devam ediyoruz. Daha sonra terminale 12eval &quot;$(ssh-agent -s)&quot;ssh-add ~/.ssh/id_rsa yazarak SSH keyini ssh-agent’e ekliyoruz. Son olarak ~/.ssh/id_rsa/id_rsa.pub dosyasını bir metin editörü ile açıp içeriğini kopyalıyoruz ve bu adresteki SSH keys → New SSH key butonuna tıklayıp açılan sayfadaki alana yapıştırıp Add SSH key butonuna tıklayıp oluşturduğumuz SSH keyini github’a eklemiş oluyoruz. 3. İlk yazıyı yazmaya başlıyoruz your-github-username.github.io klasöründe terminal penceresi açıp 1hexo new &apos;Ilk Yazi&apos; yazarak source/_posts klasöründe Ilk-Yazi.md adlı markdown dosyasını oluşturup dosyayı bir metin editörü ile düzenleyip kaydettikten sonra terminal penceresinde 12hexo generatehexo deploy komutlarını kullanarak statik site dosyalarının oluşturulmasını ve your-github-username.github.io reponuza gönderilmesini sağlayın. Kısa bir süre sonra github-pages sayfanızda görünecektir. Bir sonraki yazıda VSCode ile kullandığım markdown ve LaTeX eklentileri, Hexo’ya eklediğim bazı eklentileri ve Hexo ile kullanılan bazı kullanışlı tag’leri yazacağım.","link":"2020/05/21/Github-Pages-Uzerine-Hexo-Kurulumu/"},{"title":"OpenCV DNN ile Daha Iyi Kenar Belirleme","text":"OpenCV ile kenar belirleme için çoğunlukla Canny kenar belirleme yöntemi tercih ediliyor. Canny yönteminin yetersiz kaldığı durumlarda artık dnn ile daha gerçekçi kenar belirleme sonucu göreceğiz. Canny algoritması John F. Canny tarafından 1986’da geliştirildi. 4 aşamalı bir algoritmadır. Noise removal: Resimdeki istenmeyen gürültüyü Gaussian Filter ile azaltarak Canny algoritmasının kenar olarak algılaması engellenir. Gradient Calculation: Her piksel için Sobel, Prewitt ya da Robert operatörleriyle gradyan (görüntü yoğunluk derecesi) hesaplanır.$$Edge\\ Graident\\ (G) = { \\sqrt{G_{x}^{2} + G_{y}^{2}} }$$$$Angle\\ (\\theta) = { \\tan^{-1}(\\frac{G_{y}}{G_{x}}) }$$ Non-Maximal Suppression: Kenarlarda olmayan pikseller kaldırılır. En yüksek gradyan değeri olan pikseller kenar olarak kabul edilir. Gerçekte gradyan hesabı tek pikselde değilde komşu piksellerle birlikte yapılır. Hysteresis Thresholding: Min ve Max threshold değerine bakılarak eldeki piksellerin kenar mı değil mi olduğuna dair son karar verilir. Gradyan değeri Max değerden yüksekse kenar kabul edilir, Min değerden düşükse kenar kabul edilmez. Max ile Min arasında kalıyorsa bağlantılı olduğu kenar var mı diye bakılır eğer varsa kenar olarak kabul edilir.Bu aşamalardan sonra Canny yöntemi bitmiş ve kenar belirlenmiş olur. Canny Yönteminin SorunlarıCanny yöntemi yerel değişimlere odaklanarak kenar bulmaya çalışır, resmin içeriğine göre karar vermez. Bu sebeple her durumda güzel ve istenen sonuçlar alınmaz.İçeriğe bakarak kenar bulma derin öğrenme ya da makine öğrenmesi tabanlı yöntemler ile mümkün hale gelmiştir. OpenCV ile Derin Öğrenme Tabanlı Kenar BulmaOpenCV 3.4.3 ve üst sürümlerde kendi içinde entegre DNN modülü barındırmaya başladı. Bu DNN tabanlı kenar bulma yöntemi Holistically Nested Edge Detection ya da HED olarak bilinmeye başladı.HED, ara katmanların yan çıktılarını kullanır. Önceki katmanların çıktılarına yan çıktı denmektedir ve 5 convolutional katmanın çıktısı asıl tahmini oluşturmak için birleştirilir. Her katmanda oluşturulan özellik haritaları farklı boyutta olduğundan, görüntüye farklı ölçeklerde etkili bir şekilde bakıyor.HED yöntemi en yüksek doğrulukta sonuç üretmese de DNN tabanlı çözümler içinde en hızlısı sayılabilir. C++ ile OpenCV DNN Tabanlı Kenar Bulma YöntemiKoda geçmeden önce Caffe ile eğitilmiş model ve prototxt dosyalarını edinmek gerekiyor.OpenCV dnn::Layer sınıfından kalıtım yoluyla MyCropLayer adlı sınıf oluşturup kendi implementasyonumuzu yapacağız.MyCropLayer.hpp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;opencv2/core.hpp&gt;#include &lt;opencv2/dnn.hpp&gt;#include &lt;opencv2/dnn/layer.details.hpp&gt;#include &lt;opencv2/dnn/shape_utils.hpp&gt;#include &lt;opencv2/highgui.hpp&gt;#include &lt;opencv2/imgproc.hpp&gt;#include &lt;opencv2/opencv.hpp&gt;class MyCropLayer : public cv::dnn::Layer{ public: explicit MyCropLayer(const cv::dnn::LayerParams &amp;params); static cv::Ptr&lt;cv::dnn::Layer&gt; create(cv::dnn::LayerParams &amp;params){ return cv::Ptr&lt;Layer&gt;(new MyCropLayer(params)); } virtual bool getMemoryShapes(const std::vector&lt;std::vector&lt;int&gt;&gt; &amp;inputs, const int requiredOutputs,std::vector&lt;std::vector&lt;int&gt;&gt; &amp;outputs, std::vector&lt;std::vector&lt;int&gt;&gt; &amp;internals) const CV_OVERRIDE{ CV_UNUSED(requiredOutputs); CV_UNUSED(internals); std::vector&lt;int&gt; outShape(4); outShape[0] = inputs[0][0]; // batch size outShape[1] = inputs[0][1]; // number of channels outShape[2] = inputs[1][2]; outShape[3] = inputs[1][3]; outputs.assign(1, outShape); return false; } virtual void forward(std::vector&lt;cv::Mat *&gt; &amp;input, std::vector&lt;cv::Mat&gt; &amp;output, std::vector&lt;cv::Mat&gt; &amp;internals) CV_OVERRIDE{ cv::Mat *inp = input[0]; cv::Mat out = output[0]; int ystart = (inp-&gt;size[2] - out.size[2]) / 2; int xstart = (inp-&gt;size[3] - out.size[3]) / 2; int yend = ystart + out.size[2]; int xend = xstart + out.size[3]; const int batchSize = inp-&gt;size[0]; const int numChannels = inp-&gt;size[1]; const int height = out.size[2]; const int width = out.size[3]; int sz[] = {static_cast&lt;int&gt;(batchSize), numChannels, height, width}; out.create(4, sz, CV_32F); for (int i = 0; i &lt; batchSize; i++) { for (int j = 0; j &lt; numChannels; j++) { cv::Mat plane(inp-&gt;size[2], inp-&gt;size[3], CV_32F, inp-&gt;ptr&lt;float&gt;(i, j)); cv::Mat crop = plane(cv::Range(ystart, yend), cv::Range(xstart, xend)); cv::Mat targ(height, width, CV_32F, out.ptr&lt;float&gt;(i, j)); crop.copyTo(targ); } } } virtual void forward(cv::InputArrayOfArrays inputs_arr, cv::OutputArrayOfArrays outputs_arr, cv::OutputArrayOfArrays internals_arr) CV_OVERRIDE{ std::vector&lt;cv::Mat&gt; inputs, outputs; inputs_arr.getMatVector(inputs); outputs_arr.getMatVector(outputs); cv::Mat &amp;inp = inputs[0]; cv::Mat &amp;out = outputs[0]; int ystart = (inp.size[2] - out.size[2]) / 2; int xstart = (inp.size[3] - out.size[3]) / 2; int yend = ystart + out.size[2]; int xend = xstart + out.size[3]; const int batchSize = inp.size[0]; const int numChannels = inp.size[1]; const int height = out.size[2]; const int width = out.size[3]; int sz[] = {static_cast&lt;int&gt;(batchSize), numChannels, height, width}; out.create(4, sz, CV_32F); for (int i = 0; i &lt; batchSize; i++) { for (int j = 0; j &lt; numChannels; j++) { cv::Mat plane(inp.size[2], inp.size[3], CV_32F, inp.ptr&lt;float&gt;(i, j)); cv::Mat crop = plane(cv::Range(ystart, yend), cv::Range(xstart, xend)); cv::Mat targ(height, width, CV_32F, out.ptr&lt;float&gt;(i, j)); crop.copyTo(targ); } } }};MyCropLayer sınıfımızı implement ettikten sonra main.cpp dosyasında ilgili hpp dosyasını çağırdıktan sonra 1CV_DNN_REGISTER_LAYER_CLASS(Crop, MyCropLayer); bildirimi ile reimplement ettiğimiz sınıfı OpenCV Layer sınıfına kaydediyoruz. Böylelikle OpenCV, Crop sınıfı yerine implement ettiğimiz MyCropLayer sınıfını kullanacaktır.Yine main.cpp dosyasında bir fonksiyon oluşturalım:hedEdgeDetectDNN function from main.cpp12345678910111213141516171819void hedEdgeDetectDNN(cv::Mat &amp;image, std::string prototxt, std::string caffemodel, int size = 128){ cv::dnn::Net net = cv::dnn::readNet(prototxt, caffemodel); cv::Size reso(size, size); //image will be resized to sizexsize cv::Mat theInput; cv::resize(image, theInput, reso); cv::Mat blob = cv::dnn::blobFromImage(theInput,1.0,reso,cv::Scalar(104.00698793, 116.66876762, 122.67891434),false,false); net.setInput(blob); cv::Mat out = net.forward(); // outputBlobs contains all output blobs for each layer specified in outBlobNames. std::vector&lt;cv::Mat&gt; vectorOfImagesFromBlob; cv::dnn::imagesFromBlob(out, vectorOfImagesFromBlob); cv::Mat tmpMat = vectorOfImagesFromBlob[0] * 255; cv::Mat tmpMatUchar; cv::cvtColor(tmpMat, tmpMatUchar, cv::COLOR_GRAY2BGR); cv::resize(tmpMatUchar, image, image.size());}Fonksiyon parametrelerinde &amp;image değişkeni kaynak/hedef resmimizi gösterir. prototxt ve caffemodel değişkenleri ise prototxt ve caffemodel dosya yolunu gösterecektir. Son olarak size değişkeni ise resmin DNN ile işleme girmeden önceki ölçekleneceği boyutu ayarlamak için kullanılacaktır. Boyutun arttırılması kaliteyi arttırırken işlem süresini önemli ölçüde arttırmaktadır.Fonksiyon içeriğinde ise readNet ile model dosyası okunur. Daha sonra giriş resmi belirlenen bir boyuta ölçeklenir. Ardından blobFromImage ile görüntüden blob oluşturulup sinir ağına giriş olarak verilir.Tekrar blob’dan görüntü elde etmek için imagesFromBlob fonksiyonu çağırılır. Tek resim gönderildiği için vectorOfImagesFromBlob[0] konumundaki görüntüyü tekrar eski boyutuna getirip giriş resmine atayarak fonksiyonu bitirir. Çeşitli Resimler ve Sonuçları Orijinal (Üst) Canny (Sol alt) HED (Sağ alt) İleri okuma ve kaynaklar Tam kaynak kodu Paper - Arxiv.org Deep Learning based Edge Detection in OpenCV Opencv C++ Holistically-Nested Edge Detection Holistically-Nested Edge Detection with OpenCV and Deep Learning","link":"2020/05/12/OpenCV-DNN-ile-Daha-Iyi-Kenar-Belirleme/"},{"title":"Cisco Router Yönlendirme","text":"Ağda paketlerin doğru ağdaki alıcılara teslim edilmesi için yönlendiriciler tarafından yapılan işlem. Yönlendirici, yönlendirmek üzere aldığı paketin IP başlığındaki hedef ağ adresi (destination IP Address) alanını kullanarak yönlendirme kararı verir. Yönlendirici, kararı için belleğinde bulunan yönlendirme tablosunu (routing table) kullanır. Yönlendirme tablosu üç sütundan oluşur; Hedef ağ adresi/Hedef ağ alt ağ maskesi Hedef yönündeki komşu yönlendirici adresi Hedefe ulaşma maliyeti (metric) Yönlendirme tablosunun satırları (rotalar) üç yöntemle oluşturulabilir: Doğrudan bağlı ağ: Yönlendirici ağ arayüzü vasıtasıyla bağlı bulunan ağlar yönlendirme tablosuna otomatik olarak eklenir. Statik yollar: Ağ yöneticisinin doğrudan bağlı ağlar dışındaki ağları (uzak ağlar) elle yönlendirme komutu yazarak oluşturduğu yollar. Dinamik yollar: Dinamik yönlendirme protokolleriyle uzak ağların dinamik olarak tabloya eklenmesi. Yönlendirici aldığı bir paket için; Doğrudan bağlı ağlardaki bir alıcıya aitse alıcısına teslim eder. Uzak ağlardaki bir alıcıya aitse yönlendirme tablosundaki yollardan eşleşme bulunan sonraki yönlendiriciye teslim eder. Rotalarla eşleşme bulunamazsa siler. Yönlendirici aldığı paketin hedef IP adresi alanı ile yönlendirme tablosundaki hedef ağları eşleştirirken, hedef ağ adreslerini özelden genele doğru sıralar. Eşleşme kontrolü, paket başlığındaki hedef alt ağ maskesi AND’lenip hedef ağı elde edebilmek için yapılır. Hedef Ağ Adı/Alt Ağ Maskesi Sonraki Router Adı Metrik 1 → 192.168.1.0/24 5 → 10.0.0.0/8 3 → 172.16.0.0/16 4 → 10.0.0.0/16 2 → 95.183.162.0/24 Örnek Router A Hedef Ağ Adresi/Alt Ağ Maskesi Sonraki Router Adı Metrik 192.168.1.0/24 fa0/0 0 192.168.4.4/30 fa0/1 0 192.168.4.0/30 e0 0 192.168.2.0/24 192.168.4.6 1 192.168.3.0/24 192.168.4.2 1 Router B Hedef Ağ Adresi/Alt Ağ Maskesi Sonraki Router Adı Metrik 192.168.3.0/24 fa0/0 0 192.168.4.0/30 fa0/1 0 192.168.1.0/24 192.168.4.1 1 192.168.2.0/24 192.168.4.1 1 192.168.4.4/30 192.168.4.1 1 Router C Hedef Ağ Adresi/Alt Ağ Maskesi Sonraki Router Adı Metrik 192.168.2.0/24 fa0/0 0 192.168.4.4/30 fa0/1 0 192.168.1.0/24 192.168.4.5 1 192.168.3.0/24 192.168.4.5 1 192.168.4.0/30 192.168.4.5 1 İtalik şekildeki yapılandırmalar Router tarafından otomatik yapılmaktadır. 1R(config)#ip route hedef_ağ_adresi hedef_alt_ağ_maskesi sonraki_router_adresi [metrik]","link":"2020/03/09/cisco_router_routing/"}],"tags":[{"name":"dizi","slug":"dizi","link":"tags/dizi/"},{"name":"programlama","slug":"programlama","link":"tags/programlama/"},{"name":"c++","slug":"c","link":"tags/c/"},{"name":"cpp","slug":"cpp","link":"tags/cpp/"},{"name":"c","slug":"c","link":"tags/c/"},{"name":"array","slug":"array","link":"tags/array/"},{"name":"std::array","slug":"std-array","link":"tags/std-array/"},{"name":"Github","slug":"Github","link":"tags/Github/"},{"name":"Blog","slug":"Blog","link":"tags/Blog/"},{"name":"githubpages","slug":"githubpages","link":"tags/githubpages/"},{"name":"Hexo","slug":"Hexo","link":"tags/Hexo/"},{"name":"PWA","slug":"PWA","link":"tags/PWA/"},{"name":"AMP","slug":"AMP","link":"tags/AMP/"},{"name":"latex","slug":"latex","link":"tags/latex/"},{"name":"math","slug":"math","link":"tags/math/"},{"name":"opencv","slug":"opencv","link":"tags/opencv/"},{"name":"edge","slug":"edge","link":"tags/edge/"},{"name":"detection","slug":"detection","link":"tags/detection/"},{"name":"canny","slug":"canny","link":"tags/canny/"},{"name":"dnn","slug":"dnn","link":"tags/dnn/"},{"name":"deep learning","slug":"deep-learning","link":"tags/deep-learning/"},{"name":"cisco","slug":"cisco","link":"tags/cisco/"},{"name":"router","slug":"router","link":"tags/router/"},{"name":"yönlendirme","slug":"yonlendirme","link":"tags/yonlendirme/"},{"name":"network","slug":"network","link":"tags/network/"},{"name":"routing","slug":"routing","link":"tags/routing/"}],"categories":[{"name":"Programming","slug":"Programming","link":"categories/Programming/"},{"name":"Technology","slug":"Technology","link":"categories/Technology/"},{"name":"OpenCV","slug":"Programming/OpenCV","link":"categories/Programming/OpenCV/"},{"name":"CPP","slug":"Programming/CPP","link":"categories/Programming/CPP/"},{"name":"Network","slug":"Network","link":"categories/Network/"},{"name":"Technology","slug":"Network/Technology","link":"categories/Network/Technology/"}]}