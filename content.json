{"pages":[{"title":"about","text":"","link":"about/index.html"}],"posts":[{"title":"C Stili Dizilerden std::array'e...","text":"Programlama dillerinde diziler uygulanırken syntax olarak genelde C stili dizilerden ilham aldılar. Özellik olarak C stili dizilerin üzerine ihtiyaca göre üye fonksiyonlar da eklendi. C++11 ile gelen std::array ile C stili dizilerden çok daha fazla kullanışlılığa ve okunabilirliğe sahip kod yazılırken performans anlamında ise neredeyse aynı seviyede sayılır. std::array C stili diziler gibi statik boyutludur ve bellekte derleme zamanında yer ayrılır. std::array’ e genel bakışstd::array arka planda C stili dizinin ve ilgili üye fonksiyonlarının bulunduğu array sınıf şablonu yapısındadır. 123456789template&lt;typename T, size_t N&gt;class array{public: T _data[N]; T&amp; operator[](size_t); const T&amp; operator[](size_t) const; // other member functions and typedefs}; std::array kullanmak için #include &lt;array&gt; ile array kütüphanesi projeye eklenir. std::array uzunluğu derleme zamanında hesaplandığından ve o bilgi oluşturulan nesne içerisindeki bir değişkende saklandığından sonradan o std::array nesnesinin uzunluğunu öğrenmek kolay ve hızlıdır. std::array oluşturmakstd::array iki bileşenden oluşur: İlki array içinde saklanacak elemanların tipi ve ikincisi array nesnesinin ne kadar eleman tutacağı (yani uzunluğu). 12345//a1 dizisi 10 int tipinde eleman tutarstd::array&lt;int, 10&gt; a1;//Tanımlama sırasında değerler atanabilirstd::array&lt;int, 5&gt; a2 = {-1, 1, 3, 2, 0}; Ayrıca mevcut diziler yeni dizilere atama yoluyla kopyalanabilir. 12345//atama yoluyla yeni kopya dizi oluşturmaauto a3 = a2;//constructor ile de kopya dizi oluşturulabilirauto a4(a2); Aynı uzunluktaki başka bir dolu diziye = operatörü ile atama yapılabilir ama uzunluklar aynı olmadığında hata alınacaktır. 123456//a3 dizisi değerlerini a2 dizisine atamaa2 = a3;// &apos;=&apos; operatörü iki dizi aynı boyutta ise kullanılabilir.//Hata://a1 = a2; //&lt;[...],10&gt; vs &lt;[...],5&gt;! geçersiz std::array içindeki verilere erişmekstd::array içindeki verilere dizilerden alıştığımız şekilde [] operatörü ile de erişebiliriz ama sınır kontrolü yapmadığından dizi boyutundan farklı değerlerde hata alınacaktır. 12//beklenilen şekilde değer atamaları gerçekleşira3[0] = -2; Sınır kontrolü için at() üye fonksiyonu kullanılabilir. 1234std::cout &lt;&lt; &quot;a2.at(4): &quot; &lt;&lt; a2.at(4) &lt;&lt; std::endl;// Sınır kontrolü istisna yaratabilir. Deneyin://auto b = a2.at(10); Ayrıca front() ve back() üye fonksiyonlarıyla array nesnesindeki ilk ve son değerlere erişebiliriz. data() üye fonksiyonustd::array dolaylı yoldan raw pointera dönüşmez. Pointer temelli kullanmak isteniyorsa data() üye fonksiyonu kullanmak gerekir.Örneğin buffer arayüzü için C stili API yazalım: 1234void carr_func(int * arr, size_t size){ std::cout &lt;&lt; &quot;carr_func - arr: &quot; &lt;&lt; arr &lt;&lt; std::endl;} carr_func fonksiyonunda ilk parametreye std::array gönderirsek derleyici hatası oluşur. 123456../../array.cpp:44:2: error: no matching function for call to &apos;carr_func&apos; carr_func(a2); ^~~~~~~~~../../array.cpp:4:6: note: candidate function not viable: no known conversion from &apos;std::array&lt;int, 5&gt;&apos; to &apos;int *&apos; for 1st argumentvoid carr_func(int * arr) Bunun yerine data() üye fonksiyonunu kullanınca sorun çözülür. 12345//Error://carr_func(a2, a2.size());//OK:carr_func(a2.data(), a2.size()); size() ve empty() üye fonksiyonlarısize() üye fonksiyonuyla dizinin uzunluğu öğrenilebilir. empty() üye fonksiyonu ise dizinin içeriği boş ise true, dolu ise false döndürür. 1234a2.size(); //5std::array&lt;int, 0&gt; a_empty;a_empty.empty(); //true Container(kap) işlemleristd::array container sınıfı olduğundan temel container arayüzlerini sunmaktadır. std::array statik uzunlukta olduğundan dinamik olarak uzunluk değiştirme gibi işlemler mevcut değildir. Ancak std::sort gibi sıralama fonksiyonları kullanılabilir. 1std::sort(a1.begin(), a1.end()); İleri okuma ve kaynaklar cppreference: std::array Makaleler/Açıklamalar An Introduction to std::array C++11 Features – std::array std::array: The Secure, Convenient Option for Fixed-size Sequences","link":"2019/11/17/C-Stili-Dizilerden-std-array-e/"},{"title":"Cisco Router Yönlendirme","text":"Ağda paketlerin doğru ağdaki alıcılara teslim edilmesi için yönlendiriciler tarafından yapılan işlem. Yönlendirici, yönlendirmek üzere aldığı paketin IP başlığındaki hedef ağ adresi (destination IP Address) alanını kullanarak yönlendirme kararı verir. Yönlendirici, kararı için belleğinde bulunan yönlendirme tablosunu (routing table) kullanır. Yönlendirme tablosu üç sütundan oluşur; Hedef ağ adresi/Hedef ağ alt ağ maskesi Hedef yönündeki komşu yönlendirici adresi Hedefe ulaşma maliyeti (metric) Yönlendirme tablosunun satırları (rotalar) üç yöntemle oluşturulabilir: Doğrudan bağlı ağ: Yönlendirici ağ arayüzü vasıtasıyla bağlı bulunan ağlar yönlendirme tablosuna otomatik olarak eklenir. Statik yollar: Ağ yöneticisinin doğrudan bağlı ağlar dışındaki ağları (uzak ağlar) elle yönlendirme komutu yazarak oluşturduğu yollar. Dinamik yollar: Dinamik yönlendirme protokolleriyle uzak ağların dinamik olarak tabloya eklenmesi. Yönlendirici aldığı bir paket için; Doğrudan bağlı ağlardaki bir alıcıya aitse alıcısına teslim eder. Uzak ağlardaki bir alıcıya aitse yönlendirme tablosundaki yollardan eşleşme bulunan sonraki yönlendiriciye teslim eder. Rotalarla eşleşme bulunamazsa siler. Yönlendirici aldığı paketin hedef IP adresi alanı ile yönlendirme tablosundaki hedef ağları eşleştirirken, hedef ağ adreslerini özelden genele doğru sıralar. Eşleşme kontrolü, paket başlığındaki hedef alt ağ maskesi AND’lenip hedef ağı elde edebilmek için yapılır. Hedef Ağ Adı/Alt Ağ Maskesi Sonraki Router Adı Metrik 1 → 192.168.1.0/24 5 → 10.0.0.0/8 3 → 172.16.0.0/16 4 → 10.0.0.0/16 2 → 95.183.162.0/24 Örnek Router A Hedef Ağ Adresi/Alt Ağ Maskesi Sonraki Router Adı Metrik 192.168.1.0/24 fa0/0 0 192.168.4.4/30 fa0/1 0 192.168.4.0/30 e0 0 192.168.2.0/24 192.168.4.6 1 192.168.3.0/24 192.168.4.2 1 Router B Hedef Ağ Adresi/Alt Ağ Maskesi Sonraki Router Adı Metrik 192.168.3.0/24 fa0/0 0 192.168.4.0/30 fa0/1 0 192.168.1.0/24 192.168.4.1 1 192.168.2.0/24 192.168.4.1 1 192.168.4.4/30 192.168.4.1 1 Router C Hedef Ağ Adresi/Alt Ağ Maskesi Sonraki Router Adı Metrik 192.168.2.0/24 fa0/0 0 192.168.4.4/30 fa0/1 0 192.168.1.0/24 192.168.4.5 1 192.168.3.0/24 192.168.4.5 1 192.168.4.0/30 192.168.4.5 1 İtalik şekildeki yapılandırmalar Router tarafından otomatik yapılmaktadır. 1R(config)#ip route hedef_ağ_adresi hedef_alt_ağ_maskesi sonraki_router_adresi [metrik]","link":"2020/03/09/cisco_router_routing/"},{"title":"OpenCV DNN ile Daha Iyi Kenar Belirleme","text":"OpenCV ile kenar belirleme için çoğunlukla Canny kenar belirleme yöntemi tercih ediliyor. Canny yönteminin yetersiz kaldığı durumlarda artık dnn ile daha gerçekçi kenar belirleme sonucu göreceğiz. Canny algoritması John F. Canny tarafından 1986’da geliştirildi. 4 aşamalı bir algoritmadır. Noise removal: Resimdeki istenmeyen gürültüyü Gaussian Filter ile azaltarak Canny algoritmasının kenar olarak algılaması engellenir. Gradient Calculation: Her piksel için Sobel, Prewitt ya da Robert operatörleriyle gradyan (görüntü yoğunluk derecesi) hesaplanır. E d g e   G r a i d e n t   ( G ) = G x 2 + G y 2     A n g l e   ( θ ) = tan − 1 ⁡ ( G y G x ) Non-Maximal Suppression: Kenarlarda olmayan pikseller kaldırılır. En yüksek gradyan değeri olan pikseller kenar olarak kabul edilir. Gerçekte gradyan hesabı tek pikselde değilde komşu piksellerle birlikte yapılır. Hysteresis Thresholding: Min ve Max threshold değerine bakılarak eldeki piksellerin kenar mı değil mi olduğuna dair son karar verilir. Gradyan değeri Max değerden yüksekse kenar kabul edilir, Min değerden düşükse kenar kabul edilmez. Max ile Min arasında kalıyorsa bağlantılı olduğu kenar var mı diye bakılır eğer varsa kenar olarak kabul edilir.Bu aşamalardan sonra Canny yöntemi bitmiş ve kenar belirlenmiş olur.Canny Yönteminin SorunlarıCanny yöntemi yerel değişimlere odaklanarak kenar bulmaya çalışır, resmin içeriğine göre karar vermez. Bu sebeple her durumda güzel ve istenen sonuçlar alınmaz.İçeriğe bakarak kenar bulma derin öğrenme ya da makine öğrenmesi tabanlı yöntemler ile mümkün hale gelmiştir. OpenCV ile Derin Öğrenme Tabanlı Kenar BulmaOpenCV 3.4.3 ve üst sürümlerde kendi içinde entegre DNN modülü barındırmaya başladı. Bu DNN tabanlı kenar bulma yöntemi Holistically Nested Edge Detection ya da HED olarak bilinmeye başladı.HED, ara katmanların yan çıktılarını kullanır. Önceki katmanların çıktılarına yan çıktı denmektedir ve 5 convolutional katmanın çıktısı asıl tahmini oluşturmak için birleştirilir. Her katmanda oluşturulan özellik haritaları farklı boyutta olduğundan, görüntüye farklı ölçeklerde etkili bir şekilde bakıyor.HED yöntemi en yüksek doğrulukta sonuç üretmese de DNN tabanlı çözümler içinde en hızlısı sayılabilir. C++ ile OpenCV DNN Tabanlı Kenar Bulma YöntemiKoda geçmeden önce Caffe ile eğitilmiş model ve prototxt dosyalarını edinmek gerekiyor.OpenCV dnn::Layer sınıfından kalıtım yoluyla MyCropLayer adlı sınıf oluşturup kendi implementasyonumuzu yapacağız.MyCropLayer.hpp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;opencv2/core.hpp&gt;#include &lt;opencv2/dnn.hpp&gt;#include &lt;opencv2/dnn/layer.details.hpp&gt;#include &lt;opencv2/dnn/shape_utils.hpp&gt;#include &lt;opencv2/highgui.hpp&gt;#include &lt;opencv2/imgproc.hpp&gt;#include &lt;opencv2/opencv.hpp&gt;class MyCropLayer : public cv::dnn::Layer{ public: explicit MyCropLayer(const cv::dnn::LayerParams &amp;params); static cv::Ptr&lt;cv::dnn::Layer&gt; create(cv::dnn::LayerParams &amp;params){ return cv::Ptr&lt;Layer&gt;(new MyCropLayer(params)); } virtual bool getMemoryShapes(const std::vector&lt;std::vector&lt;int&gt;&gt; &amp;inputs, const int requiredOutputs,std::vector&lt;std::vector&lt;int&gt;&gt; &amp;outputs, std::vector&lt;std::vector&lt;int&gt;&gt; &amp;internals) const CV_OVERRIDE{ CV_UNUSED(requiredOutputs); CV_UNUSED(internals); std::vector&lt;int&gt; outShape(4); outShape[0] = inputs[0][0]; // batch size outShape[1] = inputs[0][1]; // number of channels outShape[2] = inputs[1][2]; outShape[3] = inputs[1][3]; outputs.assign(1, outShape); return false; } virtual void forward(std::vector&lt;cv::Mat *&gt; &amp;input, std::vector&lt;cv::Mat&gt; &amp;output, std::vector&lt;cv::Mat&gt; &amp;internals) CV_OVERRIDE{ cv::Mat *inp = input[0]; cv::Mat out = output[0]; int ystart = (inp-&gt;size[2] - out.size[2]) / 2; int xstart = (inp-&gt;size[3] - out.size[3]) / 2; int yend = ystart + out.size[2]; int xend = xstart + out.size[3]; const int batchSize = inp-&gt;size[0]; const int numChannels = inp-&gt;size[1]; const int height = out.size[2]; const int width = out.size[3]; int sz[] = {static_cast&lt;int&gt;(batchSize), numChannels, height, width}; out.create(4, sz, CV_32F); for (int i = 0; i &lt; batchSize; i++) { for (int j = 0; j &lt; numChannels; j++) { cv::Mat plane(inp-&gt;size[2], inp-&gt;size[3], CV_32F, inp-&gt;ptr&lt;float&gt;(i, j)); cv::Mat crop = plane(cv::Range(ystart, yend), cv::Range(xstart, xend)); cv::Mat targ(height, width, CV_32F, out.ptr&lt;float&gt;(i, j)); crop.copyTo(targ); } } } virtual void forward(cv::InputArrayOfArrays inputs_arr, cv::OutputArrayOfArrays outputs_arr, cv::OutputArrayOfArrays internals_arr) CV_OVERRIDE{ std::vector&lt;cv::Mat&gt; inputs, outputs; inputs_arr.getMatVector(inputs); outputs_arr.getMatVector(outputs); cv::Mat &amp;inp = inputs[0]; cv::Mat &amp;out = outputs[0]; int ystart = (inp.size[2] - out.size[2]) / 2; int xstart = (inp.size[3] - out.size[3]) / 2; int yend = ystart + out.size[2]; int xend = xstart + out.size[3]; const int batchSize = inp.size[0]; const int numChannels = inp.size[1]; const int height = out.size[2]; const int width = out.size[3]; int sz[] = {static_cast&lt;int&gt;(batchSize), numChannels, height, width}; out.create(4, sz, CV_32F); for (int i = 0; i &lt; batchSize; i++) { for (int j = 0; j &lt; numChannels; j++) { cv::Mat plane(inp.size[2], inp.size[3], CV_32F, inp.ptr&lt;float&gt;(i, j)); cv::Mat crop = plane(cv::Range(ystart, yend), cv::Range(xstart, xend)); cv::Mat targ(height, width, CV_32F, out.ptr&lt;float&gt;(i, j)); crop.copyTo(targ); } } }};MyCropLayer sınıfımızı implement ettikten sonra main.cpp dosyasında ilgili hpp dosyasını çağırdıktan sonra123456789101112131415161718192021222324CV_DNN_REGISTER_LAYER_CLASS(Crop, MyCropLayer);``` bildirimi ile reimplement ettiğimiz sınıfı OpenCV Layer sınıfına kaydediyoruz. Böylelikle OpenCV, Crop sınıfı yerine implement ettiğimiz MyCropLayer sınıfını kullanacaktır. Yine main.cpp dosyasında bir fonksiyon oluşturalım: ```C++ hedEdgeDetectDNN function void hedEdgeDetectDNN(cv::Mat &amp;image, std::string prototxt, std::string caffemodel, int size = 128) { cv::dnn::Net net = cv::dnn::readNet(prototxt, caffemodel); cv::Size reso(size, size); //image will be resized to sizexsize cv::Mat theInput; cv::resize(image, theInput, reso); cv::Mat blob = cv::dnn::blobFromImage(theInput,1.0,reso,cv::Scalar(104.00698793, 116.66876762, 122.67891434),false,false); net.setInput(blob); cv::Mat out = net.forward(); // outputBlobs contains all output blobs for each layer specified in outBlobNames. std::vector&lt;cv::Mat&gt; vectorOfImagesFromBlob; cv::dnn::imagesFromBlob(out, vectorOfImagesFromBlob); cv::Mat tmpMat = vectorOfImagesFromBlob[0] * 255; cv::Mat tmpMatUchar; cv::cvtColor(tmpMat, tmpMatUchar, cv::COLOR_GRAY2BGR); cv::resize(tmpMatUchar, image, image.size()); }Fonksiyon parametrelerinde &amp;image değişkeni kaynak/hedef resmimizi gösterir. prototxt ve caffemodel değişkenleri ise prototxt ve caffemodel dosya yolunu gösterecektir. Son olarak size değişkeni ise resmin DNN ile işleme girmeden önceki ölçekleneceği boyutu ayarlamak için kullanılacaktır. Boyutun arttırılması kaliteyi arttırırken işlem süresini önemli ölçüde arttırmaktadır.Fonksiyon içeriğinde ise readNet ile model dosyası okunur. Daha sonra giriş resmi belirlenen bir boyuta ölçeklenir. Ardından blobFromImage ile görüntüden blob oluşturulup sinir ağına giriş olarak verilir.Tekrar blob’dan görüntü elde etmek için imagesFromBlob fonksiyonu çağırılır. Tek resim gönderildiği için vectorOfImagesFromBlob[0] konumundaki görüntüyü tekrar eski boyutuna getirip giriş resmine atayarak fonksiyonu bitirir. Çeşitli Resimler ve Sonuçları Orijinal (Üst) Canny (Sol alt) HED (Sağ alt) İleri okuma ve kaynaklar Tam kaynak kodu Deep Learning based Edge Detection in OpenCV Opencv C++ Holistically-Nested Edge Detection Holistically-Nested Edge Detection with OpenCV and Deep Learning","link":"2020/05/12/OpenCV-DNN-ile-Daha-Iyi-Kenar-Belirleme/"}],"tags":[{"name":"dizi","slug":"dizi","link":"tags/dizi/"},{"name":"programlama","slug":"programlama","link":"tags/programlama/"},{"name":"c++","slug":"c","link":"tags/c/"},{"name":"cpp","slug":"cpp","link":"tags/cpp/"},{"name":"c","slug":"c","link":"tags/c/"},{"name":"array","slug":"array","link":"tags/array/"},{"name":"std::array","slug":"std-array","link":"tags/std-array/"},{"name":"cisco","slug":"cisco","link":"tags/cisco/"},{"name":"router","slug":"router","link":"tags/router/"},{"name":"yönlendirme","slug":"yonlendirme","link":"tags/yonlendirme/"},{"name":"network","slug":"network","link":"tags/network/"},{"name":"routing","slug":"routing","link":"tags/routing/"},{"name":"OpenCV","slug":"OpenCV","link":"tags/OpenCV/"},{"name":"C++","slug":"C","link":"tags/C/"},{"name":"edge","slug":"edge","link":"tags/edge/"},{"name":"detection","slug":"detection","link":"tags/detection/"},{"name":"canny","slug":"canny","link":"tags/canny/"},{"name":"dnn","slug":"dnn","link":"tags/dnn/"},{"name":"deep learning","slug":"deep-learning","link":"tags/deep-learning/"}],"categories":[{"name":"Programming","slug":"Programming","link":"categories/Programming/"},{"name":"Network","slug":"Network","link":"categories/Network/"},{"name":"OpenCV","slug":"OpenCV","link":"categories/OpenCV/"},{"name":"C++","slug":"Programming/C","link":"categories/Programming/C/"},{"name":"Technology","slug":"Network/Technology","link":"categories/Network/Technology/"},{"name":"C++","slug":"OpenCV/C","link":"categories/OpenCV/C/"}]}